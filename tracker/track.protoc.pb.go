// Code generated by protoc-gen-go.
// source: track.protoc
// DO NOT EDIT!

/*
Package track is a generated protocol buffer package.

It is generated from these files:
	track.protoc

It has these top-level messages:
	Tracker
*/
package tracker

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import (
	//"errors"

	"math/rand"
	"runtime"
	"strconv"
	"strings"
	"time"
)
// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Tracker struct {
	Id          int32  `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Callstack   string `protobuf:"bytes,2,opt,name=callstack" json:"callstack,omitempty"`
	Startime    int64  `protobuf:"varint,3,opt,name=startime" json:"startime,omitempty"`
	Endtime     int64  `protobuf:"varint,4,opt,name=endtime" json:"endtime,omitempty"`
	Newspace    int64  `protobuf:"varint,5,opt,name=newspace" json:"newspace,omitempty"`
	Sid         string `protobuf:"bytes,6,opt,name=sid" json:"sid,omitempty"`
	Trackertype int32  `protobuf:"varint,7,opt,name=trackertype" json:"trackertype,omitempty"`
	Function    string `protobuf:"bytes,8,opt,name=function" json:"function,omitempty"`
	Eventstr    string `protobuf:"bytes,9,opt,name=eventstr" json:"eventstr,omitempty"`
	Eventvalue  int32  `protobuf:"varint,10,opt,name=eventvalue" json:"eventvalue,omitempty"`
	Timestamp   int64  `protobuf:"varint,11,opt,name=timestamp" json:"timestamp,omitempty"`
	Serverip    int32  `protobuf:"varint,12,opt,name=serverip" json:"serverip,omitempty"`
	Serviceid   int32  `protobuf:"varint,13,opt,name=serviceid" json:"serviceid,omitempty"`
}

func (m *Tracker) Reset()                    { *m = Tracker{} }

func (this *Tracker) String() string {

	//return proto.CompactTextString(m)
	callstack := ""
	if len(this.Callstack) == 0 {
		callstack = this.Callstack + strconv.Itoa(int(this.Id))
	} else {
		callstack = this.Callstack + "." + strconv.Itoa(int(this.Id))
	}
	switch this.Trackertype {
	case TrackStart:
		return this.Sid + " "  + callstack + " Start: " + this.Function
		break
	case TrackEnd:
		return this.Sid + " " + callstack + " End: " + this.Function
		break
	case TrackEvent:
		return this.Sid + " " + callstack + " Event: " + this.Eventstr + " "
		break //可以添加
	case TrackMetric:
		return this.Sid + " " + callstack + " Metric: " + this.Eventstr + " " + strconv.Itoa(int(this.Eventvalue))
	case TrackClose:
		return this.Sid + " " + callstack + " Close: " + this.Eventstr + " " + strconv.Itoa(int(this.Eventvalue))

	default:
		return this.Sid + " " + callstack + " "

	}
	panic("")
}


func (*Tracker) ProtoMessage()               {}
func (*Tracker) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func init() {
	proto.RegisterType((*Tracker)(nil), "Tracker")
}

var fileDescriptor0 = []byte{
	// 237 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x4c, 0x50, 0x4b, 0x4e, 0xc3, 0x30,
	0x10, 0x55, 0x13, 0xda, 0x34, 0xd3, 0x82, 0x90, 0x57, 0x23, 0x84, 0x50, 0xc5, 0x8a, 0x15, 0x1b,
	0x6e, 0x12, 0x71, 0x81, 0xe0, 0x0e, 0x92, 0x45, 0xea, 0x58, 0xf6, 0x34, 0x88, 0x43, 0x73, 0x87,
	0x7a, 0x26, 0xca, 0x67, 0xf7, 0x3e, 0x7a, 0xe3, 0xf7, 0x0c, 0x47, 0x8e, 0xad, 0xfd, 0x79, 0x0f,
	0xb1, 0xe7, 0xde, 0xbe, 0xfe, 0x17, 0x50, 0x7d, 0x8a, 0x40, 0xd1, 0x3c, 0x40, 0xe1, 0xce, 0xb8,
	0x39, 0x6d, 0xde, 0xb6, 0x4d, 0x46, 0xe6, 0x19, 0x6a, 0xdb, 0x76, 0x5d, 0xe2, 0x6c, 0x63, 0x91,
	0xe5, 0xba, 0x59, 0x04, 0xf3, 0x04, 0xfb, 0x0c, 0x22, 0xbb, 0x0b, 0x61, 0x99, 0xcd, 0xb2, 0x99,
	0xb9, 0x41, 0xa8, 0xc8, 0x9f, 0xd5, 0xba, 0x53, 0x6b, 0xa2, 0x92, 0xf2, 0xf4, 0x9b, 0x42, 0x6b,
	0x09, 0xb7, 0x63, 0x6a, 0xe2, 0xe6, 0x11, 0xca, 0x94, 0x0b, 0xec, 0xf4, 0x25, 0x81, 0xe6, 0x04,
	0x07, 0x1e, 0xcb, 0xf1, 0x5f, 0x20, 0xac, 0xb4, 0xda, 0x5a, 0x92, 0x7b, 0xdf, 0x57, 0x6f, 0xd9,
	0xf5, 0x1e, 0xf7, 0x1a, 0x9c, 0xb9, 0x78, 0x34, 0x90, 0xe7, 0xc4, 0x11, 0xeb, 0xd1, 0x9b, 0xb8,
	0x79, 0x01, 0x50, 0x3c, 0xb4, 0xdd, 0x95, 0x10, 0xf4, 0xf0, 0x4a, 0x91, 0xed, 0xd2, 0x37, 0x2f,
	0xba, 0x04, 0x3c, 0x68, 0xd1, 0x45, 0xd0, 0xed, 0x14, 0x07, 0x8a, 0x2e, 0xe0, 0x51, 0xb3, 0x33,
	0x97, 0xa4, 0x60, 0x67, 0x29, 0x6f, 0xb9, 0x57, 0x73, 0x11, 0xbe, 0x76, 0xfa, 0xef, 0x1f, 0xb7,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x13, 0x36, 0x5c, 0x9b, 0x86, 0x01, 0x00, 0x00,
}


const (
	//ChannelSize = 1000
	TrackStart  = 0
	TrackEnd    = 1
	TrackEvent  = 2
	TrackMetric = 3
	TrackClose  = 4
)

func (v *Tracker) Init(Serviceid int ) {
	array := [16]string{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"}

	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	s := ""
	a := make([]string, 0)
	tnow := time.Now().Unix()
	a = append(a, strconv.Itoa(int(tnow)))
	v.Timestamp = time.Now().UnixNano()
	for j := 0; j < 5; j++ {
		for i := 0; i < 6; i++ {
			s += array[r.Intn(15)]
		}
		a = append(a, s)
		s = ""
	}
	v.Id = 0
	v.Serviceid = int32(Serviceid)
	v.Sid = strings.Join(a, "-")
}

 

func (v *Tracker) SetLine() {
	pc, file, line, _ := runtime.Caller(2)

	f := runtime.FuncForPC(pc)
	v.Function = file + ":" + strconv.Itoa(line) + " " + f.Name()

}
func (v *Tracker) Set() {

}

func (v *Tracker) Start() {
	v.SetLine()
	v.Startime = time.Now().UnixNano()
	v.Timestamp = time.Now().UnixNano()
	v.Id += 1

	t := &Tracker{}
	fmt.Printf("start address: %p\n", t)
	*t = *v
	t.Trackertype = TrackStart
	Gsender.Send(t)
}

func (v *Tracker) End() {
	v.Startime = time.Now().UnixNano()
	v.Endtime = time.Now().UnixNano()
	v.Timestamp = time.Now().UnixNano()
	v.SetLine()
	t := &Tracker{}
	fmt.Printf("end address: %p\n", t)
	*t = *v
	t.Trackertype = TrackEnd
	Gsender.Send(t)

}


func (v *Tracker) Close() {
	v.Startime = time.Now().UnixNano()
	v.Endtime = time.Now().UnixNano()
	v.Timestamp = time.Now().UnixNano()
	v.SetLine()
	v.Id += 1
	t := &Tracker{}
	 
	*t = *v
	t.Trackertype = TrackClose
	Gsender.Send(t)

}

func (v *Tracker) Event(eventstr string) {
	v.Startime = time.Now().UnixNano()
	v.Endtime = time.Now().UnixNano()
	v.Timestamp = time.Now().UnixNano()
	v.SetLine()
	v.Id += 1
	t := &Tracker{}
	fmt.Printf("event address: %p\n", t)
	*t = *v
	t.Eventstr = eventstr
	t.Trackertype = TrackEvent
	Gsender.Send(t)
}

func (v *Tracker) Metric(eventstr string, value int) {
	v.Startime = time.Now().UnixNano()
	v.Endtime = time.Now().UnixNano()
	v.Timestamp = time.Now().UnixNano()
	v.SetLine()
	v.Id += 1
	t := &Tracker{}
	
	*t = *v
	t.Eventstr = eventstr
	t.Eventvalue = int32(value)
	t.Trackertype = TrackMetric
	Gsender.Send(t)

}

func (v *Tracker) Clone() *Tracker {
	v.Startime = time.Now().UnixNano()
	t := &Tracker{}
	v.SetLine()
	v.Timestamp = time.Now().UnixNano()
	v.Id += 1
	*t = *v
	return t
}

func (v *Tracker) NewSpace() {
	if len(v.Callstack) == 0 {
		v.Callstack += strconv.Itoa(int(v.Id))
	} else {
		v.Callstack += "." + strconv.Itoa(int(v.Id))
	}

	v.Id = 0
}

type Sender interface {
	Send(v *Tracker)
	SendToServer()
}

var Gsender Sender


